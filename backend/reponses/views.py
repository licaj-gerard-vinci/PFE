
from django.http import Http404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from backend.models import Admin, ReponseClient, Verifications, Reponses
from django.shortcuts import get_object_or_404


# Create your views here.

class AddVerificationView(APIView):
    def post(self, request, client_id):
        '''
        CrÃ©e des vÃ©rifications pour toutes les rÃ©ponses d'un client spÃ©cifiÃ©.
        :param client_id: L'ID du client pour lequel les vÃ©rifications doivent Ãªtre crÃ©Ã©es
        :param request: La requÃªte HTTP
        :return: Un message de succÃ¨s ou d'erreur

        Exemple de route:
        POST /verifications/1/add/

        Exemple de corps de requÃªte:
        {
            "id_admin": 1
        }

        Exemple de rÃ©ponse:
        {
            "message": "VÃ©rifications crÃ©Ã©es pour toutes les rÃ©ponses du client 1."
        }

        '''

        # RÃ©cupÃ©rer les donnÃ©es de la requÃªte
        admin_id = request.data['id_admin']  # Assurez-vous que l'utilisateur connectÃ© est un admin
        try:

            # VÃ©rifiez si l'utilisateur est bien un admin
            admin = get_object_or_404(Admin, id_admin=admin_id)

            # RÃ©cupÃ©rez toutes les rÃ©ponses du client spÃ©cifiÃ©
            reponses_clients = ReponseClient.objects.filter(id_client=client_id)
            if not reponses_clients.exists():
                return Response({"error": "Aucune rÃ©ponse trouvÃ©e pour ce client."}, status=status.HTTP_404_NOT_FOUND)
            # CrÃ©er les vÃ©rifications pour chaque rÃ©ponse du client
            for reponse_client in reponses_clients:
                Verifications.objects.create(
                    id_reponse_client=reponse_client,
                    est_valide=False,  # Par dÃ©faut non validÃ©
                    id_admin=admin.id_admin
                )

            return Response(
                {"message": f"VÃ©rifications crÃ©Ã©es pour toutes les rÃ©ponses du client {client_id}."},
                status=status.HTTP_201_CREATED
            )
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


class ValidateQuestionView(APIView):
    def post(self, request, verification_id):
        '''
        Valide une vÃ©rification spÃ©cifique.
        :param verification_id: L'ID de la vÃ©rification Ã  valider
        :param request: La requÃªte HTTP
        :return: Un message de succÃ¨s ou d'erreur
        '''
        # RÃ©cupÃ©rer l'ID de l'admin depuis la requÃªte
        admin_id = request.data.get('id_admin')

        # Validation de l'ID de l'admin
        if not admin_id:
            return Response({"error": "L'ID de l'admin est requis."}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # VÃ©rifiez que l'admin existe
            admin = get_object_or_404(Admin, id_admin=admin_id)
        except Http404:
            return Response({"error": "Admin non trouvÃ©."}, status=status.HTTP_404_NOT_FOUND)

        try:
            # RÃ©cupÃ©rer la vÃ©rification spÃ©cifique
            verification = get_object_or_404(Verifications, id_reponse_client=verification_id)

            # Valider la vÃ©rification
            verification.est_valide = True
            verification.save()

            # Retourner un succÃ¨s
            return Response(
                {"message": f"VÃ©rification {verification_id} validÃ©e avec succÃ¨s."},
                status=status.HTTP_200_OK
            )

        except Http404:
            return Response({"error": "VÃ©rification non trouvÃ©e."}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": f"Erreur inattendue : {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)


class GetVerificationsView(APIView):
    def get(self, request, client_id):
        '''
        RÃ©cupÃ¨re toutes les vÃ©rifications pour un client spÃ©cifiÃ©.
        :param client_id: L'ID du client pour lequel les vÃ©rifications doivent Ãªtre rÃ©cupÃ©rÃ©es
        :return: Les vÃ©rifications pour le client spÃ©cifiÃ©

        Exemple de route:
        GET /verifications/client/1/

        Exemple de rÃ©ponse:
        [
            {
                "id_verification": 1,
                "id_reponse_client": 1,
                "est_valide": False,
                "id_admin": 1
            },
            {
                "id_verification": 2,
                "id_reponse_client": 2,
                "est_valide": False,
                "id_admin": 1
            }
        ]
        '''

        try:
            # RÃ©cupÃ©rer toutes les vÃ©rifications pour le client spÃ©cifiÃ©
            reponses_clients = ReponseClient.objects.filter(id_client=client_id)
            if not reponses_clients.exists():
                return Response({"error": "Aucune rÃ©ponse trouvÃ©e pour ce client."}, status=status.HTTP_404_NOT_FOUND)
            verifications = Verifications.objects.filter(id_reponse_client__in=reponses_clients)
            if not verifications.exists():
                return Response({"error": "Aucune vÃ©rification trouvÃ©e pour ce client."},
                                status=status.HTTP_404_NOT_FOUND)
            # RÃ©cupÃ©rer les donnÃ©es de chaque vÃ©rification
            data = []
            for verification in verifications:
                data.append({
                    "id_verification": verification.id_reponse_client.id_reponse_client,
                    "id_reponse_client": verification.id_reponse_client.id_reponse_client,
                    "est_valide": verification.est_valide,
                    "id_admin": verification.id_admin
                })

            return Response(data, status=status.HTTP_200_OK)
        except Exception as e:
            print("2ğŸ”´ BAD REQUEST: ", e)
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


class DeleteReponseClientView(APIView):
    def delete(self, request, reponse_client_id):
        '''
        Supprime une rÃ©ponse client et sa vÃ©rification associÃ©e si la question de la rÃ©ponse client a au moins une autre rÃ©ponse.
        :param reponse_client_id: L'ID de la rÃ©ponse client Ã  supprimer.
        :param request: La requÃªte HTTP.
        :return: Un message de succÃ¨s ou d'erreur.
        '''
        try:
            # RÃ©cupÃ©rer la rÃ©ponse client spÃ©cifique
            reponse_client = get_object_or_404(ReponseClient, id_reponse_client=reponse_client_id)
            # RÃ©cupÃ©rer la question associÃ©e via la relation
            question = reponse_client.id_reponse.id_question
            # RÃ©cupÃ©rer toutes les rÃ©ponses client pour cette question
            reponses_clients = ReponseClient.objects.filter(id_reponse__id_question=question.id_question)

            # VÃ©rifier si la question a plus d'une rÃ©ponse
            if reponses_clients.count() > 1:
                # Supprimer la rÃ©ponse client
                reponse_client.delete()

                # Supprimer la vÃ©rification associÃ©e, si elle existe
                verification = Verifications.objects.filter(id_reponse_client=reponse_client_id).first()
                if verification:
                    verification.delete()

                # Retourner un succÃ¨s
                return Response(
                    {"message": f"RÃ©ponse client {reponse_client_id} supprimÃ©e avec succÃ¨s."},
                    status=status.HTTP_200_OK
                )
            else:
                return Response(
                    {"error": "Impossible de supprimer la rÃ©ponse car la question n'a qu'une seule rÃ©ponse."},
                    status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({"error": "RÃ©ponse client non trouvÃ©e."}, status=status.HTTP_404_NOT_FOUND)
        except AttributeError as e:
            print("AttributeError: ", e)
        except Exception as e:
            return Response({"error": f"Erreur inattendue : {str(e)}"}, status=status.HTTP_412_PRECONDITION_FAILED)


# CrÃ©e moi une classe qui me permet de modifier Le contenu de la rÃ©ponse si un champ libre == True et de modifier le score_final de la rÃ©ponse_client

class UpdateReponseClientView(APIView):
    def put(self, request, reponse_client_id):
        '''
        Modifie le contenu d'une rÃ©ponse client si le champ libre est activÃ©.
        :param reponse_client_id: L'ID de la rÃ©ponse client Ã  modifier.
        :param request: La requÃªte HTTP.
        :return: Un message de succÃ¨s ou d'erreur.

        Exemple de route:
        PUT /reponse_client/1/update/
        Exemple de corps de requÃªte:
        {
            "contenu": "Nouveau contenu de la rÃ©ponse",
            "score_final": 10
        }

        Exemple de rÃ©ponse:
        {
            "message": "RÃ©ponse client 1 modifiÃ©e avec succÃ¨s."
        }

        '''

        try:
            # fixme: elle ne met pas Ã  jour les donnÃ©es en base de donnÃ©es
            # VÃ©rifier si le contenu et le score_final sont prÃ©sents dans la requÃªte
            if 'contenu' not in request.data or 'score_final' not in request.data:
                print("ğŸ”´ BAD REQUEST: ", request.data)
                return Response({"error": "Le contenu et le score final sont requis."},
                                status=status.HTTP_400_BAD_REQUEST)
            # RÃ©cupÃ©rer la rÃ©ponse client spÃ©cifique
            reponse_client = get_object_or_404(ReponseClient, id_reponse_client=reponse_client_id)
            print("1ğŸŸ¨ reponse_client: ", reponse_client)

            print(f"2ğŸŸ¨ Q{reponse_client.id_reponse.id_reponse} => ")
            reponse = Reponses.objects.get(id_reponse=reponse_client.id_reponse.id_reponse)
            print("3ğŸŸ¨ champ_libre: ", reponse.champ_libre)
            # VÃ©rifier si le champ libre est activÃ©            # VÃ©rifier si le champ libre est activÃ©
            if reponse.champ_libre:
                # Modifier le contenu de la rÃ©ponse client
                reponse.texte = request.data.get('contenu')

                # Modifier le score final de la rÃ©ponse client
                reponse_client.score_final = request.data.get('score_final')
                reponse_client.save()

                # Retourner un succÃ¨s
                return Response(
                    {"message": f"RÃ©ponse client {reponse_client_id} modifiÃ©e avec succÃ¨s."},
                    status=status.HTTP_200_OK
                )
            else:
                return Response({"error": "Impossible de modifier la rÃ©ponse car le champ libre n'est pas activÃ©."},
                                status=status.HTTP_412_PRECONDITION_FAILED)

        except Http404:
            return Response({"error": "RÃ©ponse client non trouvÃ©e."}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": f"Erreur inattendue : {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)
